/*
 * MASM Assembly Output Module
 * Generates Microsoft Macro Assembler (MASM) assembly code for Windows x64
 */

#include "masm_output.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * MASM Assembly Context
 */

MASMContext* masm_context_new(AssemblyContext *asm_ctx) {
    MASMContext *ctx = malloc(sizeof(MASMContext));
    if (!ctx) return NULL;
    
    memset(ctx, 0, sizeof(MASMContext));
    ctx->asm_ctx = asm_ctx;
    
    /* Initialize output buffer */
    ctx->output_capacity = 8192;  /* Start with 8KB */
    ctx->output_buffer = malloc(ctx->output_capacity);
    if (!ctx->output_buffer) {
        free(ctx);
        return NULL;
    }
    
    ctx->output_size = 0;
    ctx->indent_level = 0;
    ctx->string_counter = 0;
    
    return ctx;
}

void masm_context_free(MASMContext *ctx) {
    if (!ctx) return;
    
    if (ctx->output_buffer) free(ctx->output_buffer);
    free(ctx);
}

/*
 * Output Buffer Management
 */

static Bool masm_ensure_capacity(MASMContext *ctx, size_t needed) {
    if (ctx->output_size + needed <= ctx->output_capacity) {
        return true;
    }
    
    size_t new_capacity = ctx->output_capacity * 2;
    while (new_capacity < ctx->output_size + needed) {
        new_capacity *= 2;
    }
    
    char *new_buffer = realloc(ctx->output_buffer, new_capacity);
    if (!new_buffer) return false;
    
    ctx->output_buffer = new_buffer;
    ctx->output_capacity = new_capacity;
    
    return true;
}

static Bool masm_append_string(MASMContext *ctx, const char *str) {
    size_t len = strlen(str);
    if (!masm_ensure_capacity(ctx, len + 1)) return false;
    
    strcpy(ctx->output_buffer + ctx->output_size, str);
    ctx->output_size += len;
    
    return true;
}

static Bool masm_append_line(MASMContext *ctx, const char *line) {
    /* Add indentation */
    for (int i = 0; i < ctx->indent_level; i++) {
        if (!masm_append_string(ctx, "    ")) return false;
    }
    
    /* Add the line */
    if (!masm_append_string(ctx, line)) return false;
    
    /* Add newline */
    if (!masm_append_string(ctx, "\n")) return false;
    
    return true;
}

/*
 * MASM Assembly Generation
 */

Bool masm_generate_user_main_function(MASMContext *ctx, ASTNode *ast) {
    if (!ctx || !ast) return false;
    
    /* Generate main function that contains all global statements */
    masm_append_line(ctx, "; Main function");
    masm_append_line(ctx, "main PROC");
    ctx->indent_level++;
    
    /* Function prologue */
    masm_append_line(ctx, "push rbp        ; Save caller's frame pointer");
    masm_append_line(ctx, "mov rbp, rsp    ; Set up new frame pointer");
    masm_append_line(ctx, "sub rsp, 32h    ; Allocate local space");
    
    /* Process all global statements - but skip function declarations */
    ASTNode *child = ast->children;
    while (child) {
        if (child->type == NODE_FUNCTION) {
            /* For function nodes, only process the body, not the declaration */
            if (child->data.function.body) {
                if (!masm_generate_ast_node(ctx, child->data.function.body)) {
                    printf("ERROR: Failed to generate MASM for function body\n");
                    return false;
                }
            }
        } else {
            /* Process other global statements normally */
            if (!masm_generate_ast_node(ctx, child)) {
                printf("ERROR: Failed to generate MASM for AST node type %d\n", child->type);
                return false;
            }
        }
        child = child->next;
    }
    
    /* Function epilogue */
    masm_append_line(ctx, "mov rsp, rbp    ; Restore stack pointer");
    masm_append_line(ctx, "pop rbp         ; Restore caller's frame pointer");
    masm_append_line(ctx, "ret             ; Return to caller");
    
    ctx->indent_level--;
    masm_append_line(ctx, "main ENDP");
    
    return true;
}

Bool masm_generate_header(MASMContext *ctx) {
    if (!ctx) return false;
    
    /* MASM header for x64 Windows */
    masm_append_line(ctx, "; Generated by SchismC - MASM Assembly Output");
    masm_append_line(ctx, "; Target: Windows x64");
    masm_append_line(ctx, "");
    
    /* External function declarations */
    masm_append_line(ctx, "extrn GetStdHandle:PROC");
    masm_append_line(ctx, "extrn WriteConsoleA:PROC");
    masm_append_line(ctx, "extrn ExitProcess:PROC");
    masm_append_line(ctx, "");
    
    /* Data section for string literals */
    masm_append_line(ctx, ".data");
    masm_append_line(ctx, "str_literal_0 DB \"Hello, World!\", 0");
    masm_append_line(ctx, "");
    
    /* Code section */
    masm_append_line(ctx, ".code");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_entry_point(MASMContext *ctx) {
    if (!ctx) return false;
    
    /* No separate entry point needed - main is the entry point */
    return true;
}

Bool masm_generate_user_main(MASMContext *ctx) {
    if (!ctx) return false;
    
    /* No separate user_main needed - everything goes in main */
    return true;
}

Bool masm_generate_footer(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "END");
    
    return true;
}

/*
 * Main MASM Generation Function
 */

Bool masm_generate_assembly(MASMContext *ctx, const char *filename) {
    if (!ctx || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly file: %s\n", filename);
    
    /* Generate MASM assembly */
    if (!masm_generate_header(ctx)) return false;
    if (!masm_generate_entry_point(ctx)) return false;
    if (!masm_generate_user_main(ctx)) return false;
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Function-related MASM Generation
 */

Bool masm_generate_function_declaration(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_FUNCTION) return false;
    
    printf("DEBUG: Generating MASM function declaration: %s\n", 
           node->data.function.name ? (char*)node->data.function.name : "unknown");
    
    /* Generate function signature */
    char func_sig[256];
    snprintf(func_sig, sizeof(func_sig), "%s PROC", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    
    masm_append_line(ctx, "");
    masm_append_line(ctx, func_sig);
    ctx->indent_level++;
    
    /* Generate function prologue */
    masm_append_line(ctx, "; Function prologue");
    masm_append_line(ctx, "    push rbp        ; Save caller's frame pointer");
    masm_append_line(ctx, "    mov rbp, rsp    ; Set up new frame pointer");
    
    /* Calculate local variable space */
    I64 local_space = 32; /* Default shadow space */
    /* TODO: Count parameters from parameter list */
    /* For now, use default shadow space */
    
    char sub_instr[64];
    snprintf(sub_instr, sizeof(sub_instr), "    sub rsp, %ldh    ; Allocate local space", local_space);
    masm_append_line(ctx, sub_instr);
    masm_append_line(ctx, "");
    
    /* Generate function body */
    if (node->data.function.body) {
        masm_append_line(ctx, "; Function body");
        if (!masm_generate_ast_node(ctx, node->data.function.body)) {
            printf("ERROR: Failed to generate MASM for function body\n");
            return false;
        }
    }
    
    /* Generate function epilogue */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Function epilogue");
    masm_append_line(ctx, "    mov rsp, rbp    ; Restore stack pointer");
    masm_append_line(ctx, "    pop rbp         ; Restore caller's frame pointer");
    masm_append_line(ctx, "    ret             ; Return to caller");
    
    ctx->indent_level--;
    
    /* Generate function end */
    char func_end[256];
    snprintf(func_end, sizeof(func_end), "%s ENDP", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    masm_append_line(ctx, func_end);
    
    printf("DEBUG: Generated MASM function declaration successfully\n");
    return true;
}

Bool masm_generate_function_call(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_CALL) return false;
    
    printf("DEBUG: Generating MASM function call: %s\n", 
           node->data.call.name ? (char*)node->data.call.name : "unknown");
    
    I64 arg_count = node->data.call.arg_count;
    
    /* Allocate shadow space if we have arguments */
    if (arg_count > 0) {
        masm_append_line(ctx, "; Allocate shadow space");
        masm_append_line(ctx, "    sub rsp, 20h    ; 32 bytes shadow space");
    }
    
    /* Generate argument passing */
    if (node->data.call.arguments && node->data.call.arguments->data.block.statements) {
        ASTNode *arg = node->data.call.arguments->data.block.statements;
        I64 arg_index = 0;
        
        masm_append_line(ctx, "; Pass arguments");
        
        while (arg && arg_index < arg_count) {
            if (arg_index < 4) {
                /* First 4 arguments go in registers */
                const char *reg_names[] = {"rcx", "rdx", "r8", "r9"};
                
                /* Generate code to evaluate argument and move to register */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for argument %lld\n", arg_index);
                    return false;
                }
                
                /* Move result to appropriate register */
                char mov_instr[64];
                snprintf(mov_instr, sizeof(mov_instr), "    mov %s, rax    ; Argument %ld", 
                         reg_names[arg_index], arg_index);
                masm_append_line(ctx, mov_instr);
                
            } else {
                /* Additional arguments go on stack */
                /* Generate code to evaluate argument */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for stack argument %lld\n", arg_index);
                    return false;
                }
                
                /* Push argument onto stack */
                masm_append_line(ctx, "    push rax        ; Stack argument");
            }
            
            arg = arg->next;
            arg_index++;
        }
    }
    
    /* Generate function call */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Call function");
    char call_instr[128];
    snprintf(call_instr, sizeof(call_instr), "    call %s", 
             node->data.call.name ? (char*)node->data.call.name : "unknown_func");
    masm_append_line(ctx, call_instr);
    
    /* Clean up stack arguments */
    if (arg_count > 4) {
        I64 stack_args = arg_count - 4;
        char cleanup_instr[64];
        snprintf(cleanup_instr, sizeof(cleanup_instr), "    add rsp, %ldh    ; Clean up stack arguments", 
                 stack_args * 8);
        masm_append_line(ctx, cleanup_instr);
    }
    
    /* Restore shadow space */
    if (arg_count > 0) {
        masm_append_line(ctx, "    add rsp, 20h    ; Restore shadow space");
    }
    
    printf("DEBUG: Generated MASM function call successfully\n");
    return true;
}

Bool masm_generate_return_statement(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_RETURN) return false;
    
    printf("DEBUG: Generating MASM return statement\n");
    
    /* Check if we have a return value or expression */
    if (node->data.return_stmt.return_value != 0) {
        /* Simple return value (integer literal) */
        I64 return_value = node->data.return_stmt.return_value;
        
        char mov_instr[64];
        snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Return value", return_value);
        masm_append_line(ctx, mov_instr);
        
    } else if (node->data.return_stmt.expression) {
        /* Complex return expression */
        masm_append_line(ctx, "; Evaluate return expression");
        if (!masm_generate_ast_node(ctx, node->data.return_stmt.expression)) {
            printf("ERROR: Failed to generate MASM for return expression\n");
            return false;
        }
        masm_append_line(ctx, "; Result is in rax");
        
    } else {
        /* No return value - just return */
        masm_append_line(ctx, "; Return void");
    }
    
    printf("DEBUG: Generated MASM return statement successfully\n");
    return true;
}

Bool masm_generate_ast_node(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node) return false;
    
    switch (node->type) {
        case NODE_FUNCTION:
            return masm_generate_function_declaration(ctx, node);
            
        case NODE_CALL:
            return masm_generate_function_call(ctx, node);
            
        case NODE_RETURN:
            return masm_generate_return_statement(ctx, node);
            
        case NODE_INTEGER: {
            /* Generate immediate value */
            char mov_instr[64];
            snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Integer literal", 
                     node->data.literal.i64_value);
            masm_append_line(ctx, mov_instr);
            return true;
        }
            
        case NODE_STRING: {
            /* Generate string literal - in HolyC, strings are automatically printed */
            printf("DEBUG: masm_generate_ast_node - processing NODE_STRING\n");
            if (node->data.literal.str_value) {
                printf("DEBUG: masm_generate_ast_node - string value: %s\n", node->data.literal.str_value);
                
                /* In HolyC, string literals are automatically printed (sent to Print()) */
                /* Generate assembly to call Print() with the string literal */
                char str_label[64];
                snprintf(str_label, sizeof(str_label), "str_literal_%d", ctx->string_counter);
                
                /* Generate Windows API call to WriteConsoleA */
                masm_append_line(ctx, "; Get stdout handle");
                masm_append_line(ctx, "mov rcx, -11        ; STD_OUTPUT_HANDLE");
                masm_append_line(ctx, "call GetStdHandle");
                masm_append_line(ctx, "mov rdi, rax        ; Save handle");
                
                masm_append_line(ctx, "; Write string to console");
                masm_append_line(ctx, "mov rcx, rdi        ; hConsoleOutput");
                masm_append_line(ctx, "lea rdx, [str_literal_0]  ; lpBuffer");
                masm_append_line(ctx, "mov r8, 13          ; nNumberOfCharsToWrite (length of 'Hello, World!')");
                masm_append_line(ctx, "mov r9, 0           ; lpNumberOfCharsWritten (NULL)");
                masm_append_line(ctx, "push 0              ; lpReserved (NULL)");
                masm_append_line(ctx, "sub rsp, 32         ; Shadow space");
                masm_append_line(ctx, "call WriteConsoleA");
                masm_append_line(ctx, "add rsp, 40         ; Clean up stack");
                
                ctx->string_counter++;  /* Increment counter for next string */
                
                printf("DEBUG: masm_generate_ast_node - generated string print assembly\n");
            } else {
                printf("DEBUG: masm_generate_ast_node - no string value\n");
                masm_append_line(ctx, "; String literal: (null)");
            }
            printf("DEBUG: masm_generate_ast_node - NODE_STRING completed successfully\n");
            return true;
        }
            
        case NODE_BLOCK:
            /* Generate block statements */
            printf("DEBUG: masm_generate_ast_node - processing NODE_BLOCK\n");
            if (node->data.block.statements) {
                ASTNode *stmt = node->data.block.statements;
                int stmt_count = 0;
                while (stmt) {
                    printf("DEBUG: masm_generate_ast_node - processing block statement %d, type %d\n", stmt_count, stmt->type);
                    if (!masm_generate_ast_node(ctx, stmt)) {
                        printf("ERROR: Failed to generate MASM for block statement\n");
                        return false;
                    }
                    stmt = stmt->next;
                    stmt_count++;
                }
                printf("DEBUG: masm_generate_ast_node - processed %d block statements\n", stmt_count);
            } else {
                printf("DEBUG: masm_generate_ast_node - no block statements\n");
            }
            return true;
            
        case NODE_IDENTIFIER: {
            /* Generate variable reference - load from stack frame */
            if (node->data.identifier.name) {
                /* Check if this is a parameter or local variable */
                if (node->data.identifier.stack_offset >= 0) {
                    /* Local variable or parameter - load from stack frame */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov rax, [rbp%+ld]    ; Load variable %s", 
                             node->data.identifier.stack_offset, (char*)node->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                } else {
                    /* Global variable - load from data section */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov rax, [%s]    ; Load global variable %s", 
                             (char*)node->data.identifier.name, (char*)node->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                }
            } else {
                /* Fallback for unnamed identifier */
                masm_append_line(ctx, "    mov rax, 0    ; Unnamed identifier");
            }
            return true;
        }
            
        case NODE_VARIABLE: {
            /* Variable declaration - no code generation needed, just scope management */
            printf("DEBUG: Processing variable declaration: %s\n", 
                   node->data.identifier.name ? (char*)node->data.identifier.name : "unnamed");
            return true;
        }
            
        case NODE_ASSIGNMENT: {
            /* Generate assignment - evaluate right side, store in left side */
            if (!masm_generate_ast_node(ctx, node->data.assignment.right)) {
                printf("ERROR: Failed to generate MASM for assignment right-hand side\n");
                return false;
            }
            
            /* Save the value to be assigned */
            masm_append_line(ctx, "    push rax        ; Save value to be assigned");
            
            /* Generate address calculation for the left side */
            if (node->data.assignment.left) {
                if (node->data.assignment.left->type == NODE_SUB_INT_ACCESS) {
                    /* Sub-int access assignment (i.u16[1] = value) */
                    printf("DEBUG: Generating MASM sub-int access assignment\n");
                    
                    /* Generate base object address */
                    if (!masm_generate_ast_node(ctx, node->data.assignment.left->data.sub_int_access.base_object)) {
                        printf("ERROR: Failed to generate MASM for sub-int access base object in assignment\n");
                        return false;
                    }
                    
                    /* Save base object address */
                    masm_append_line(ctx, "    push rax        ; Save base object address");
                    
                    /* Generate index expression */
                    if (!masm_generate_ast_node(ctx, node->data.assignment.left->data.sub_int_access.index)) {
                        printf("ERROR: Failed to generate MASM for sub-int access index in assignment\n");
                        return false;
                    }
                    
                    /* Calculate offset: index * member_size */
                    I64 member_size = node->data.assignment.left->data.sub_int_access.member_size;
                    if (member_size > 1) {
                        char mul_instr[64];
                        snprintf(mul_instr, sizeof(mul_instr), "    imul rax, %ld    ; Multiply index by member size", (long)member_size);
                        masm_append_line(ctx, mul_instr);
                    }
                    
                    /* Add offset to base address */
                    masm_append_line(ctx, "    pop rbx         ; Restore base object address");
                    masm_append_line(ctx, "    add rbx, rax    ; Add offset to base address");
                    
                    /* Restore the value to be assigned */
                    masm_append_line(ctx, "    pop rax         ; Restore value to be assigned");
                    
                    /* Store the value with appropriate size */
                    U8 *member_type = node->data.assignment.left->data.sub_int_access.member_type;
                    if (member_type) {
                        if (strcmp(member_type, "i8") == 0 || strcmp(member_type, "u8") == 0) {
                            masm_append_line(ctx, "    mov [rbx], al    ; Store 8-bit value");
                        } else if (strcmp(member_type, "i16") == 0 || strcmp(member_type, "u16") == 0) {
                            masm_append_line(ctx, "    mov [rbx], ax    ; Store 16-bit value");
                        } else if (strcmp(member_type, "i32") == 0 || strcmp(member_type, "u32") == 0) {
                            masm_append_line(ctx, "    mov [rbx], eax   ; Store 32-bit value");
                        } else {
                            masm_append_line(ctx, "    mov [rbx], rax   ; Store 64-bit value");
                        }
                    } else {
                        masm_append_line(ctx, "    mov [rbx], rax   ; Store value");
                    }
                    
                } else if (node->data.assignment.left->type == NODE_UNION_MEMBER_ACCESS) {
                    /* Union member access assignment (union_var.member[index] = value) */
                    printf("DEBUG: Generating MASM union member access assignment\n");
                    
                    /* Generate union object address */
                    if (!masm_generate_ast_node(ctx, node->data.assignment.left->data.union_member_access.union_object)) {
                        printf("ERROR: Failed to generate MASM for union member access object in assignment\n");
                        return false;
                    }
                    
                    /* Save union object address */
                    masm_append_line(ctx, "    push rax        ; Save union object address");
                    
                    /* Generate index expression */
                    if (!masm_generate_ast_node(ctx, node->data.assignment.left->data.union_member_access.index)) {
                        printf("ERROR: Failed to generate MASM for union member access index in assignment\n");
                        return false;
                    }
                    
                    /* Calculate offset: index * member_size */
                    I64 member_size = node->data.assignment.left->data.union_member_access.member_size;
                    if (member_size > 1) {
                        char mul_instr[64];
                        snprintf(mul_instr, sizeof(mul_instr), "    imul rax, %ld    ; Multiply index by member size", (long)member_size);
                        masm_append_line(ctx, mul_instr);
                    }
                    
                    /* Add offset to union address */
                    masm_append_line(ctx, "    pop rbx         ; Restore union object address");
                    masm_append_line(ctx, "    add rbx, rax    ; Add offset to union address");
                    
                    /* Restore the value to be assigned */
                    masm_append_line(ctx, "    pop rax         ; Restore value to be assigned");
                    
                    /* Store the value */
                    masm_append_line(ctx, "    mov [rbx], rax  ; Store union member value");
                    
                } else if (node->data.assignment.left->data.identifier.name) {
                    /* Regular variable assignment */
                    /* Restore the value to be assigned */
                    masm_append_line(ctx, "    pop rax         ; Restore value to be assigned");
                    
                    if (node->data.assignment.left->data.identifier.stack_offset >= 0) {
                        /* Local variable or parameter - store in stack frame */
                        char mov_instr[128];
                        snprintf(mov_instr, sizeof(mov_instr), "    mov [rbp%+ld], rax    ; Store in variable %s", 
                                 node->data.assignment.left->data.identifier.stack_offset, 
                                 (char*)node->data.assignment.left->data.identifier.name);
                        masm_append_line(ctx, mov_instr);
                    } else {
                        /* Global variable - store in data section */
                        char mov_instr[128];
                        snprintf(mov_instr, sizeof(mov_instr), "    mov [%s], rax    ; Store in global variable %s", 
                                 (char*)node->data.assignment.left->data.identifier.name,
                                 (char*)node->data.assignment.left->data.identifier.name);
                        masm_append_line(ctx, mov_instr);
                    }
                } else {
                    /* Fallback - just restore the value */
                    masm_append_line(ctx, "    pop rax         ; Restore value to be assigned");
                }
            } else {
                /* No left side - just restore the value */
                masm_append_line(ctx, "    pop rax         ; Restore value to be assigned");
            }
            return true;
        }
            
        case NODE_BINARY_OP: {
            /* Generate binary operation */
            if (!masm_generate_ast_node(ctx, node->data.binary_op.left)) {
                printf("ERROR: Failed to generate MASM for left operand\n");
                return false;
            }
            
            /* Save left operand */
            masm_append_line(ctx, "    push rax        ; Save left operand");
            
            /* Generate right operand */
            if (!masm_generate_ast_node(ctx, node->data.binary_op.right)) {
                printf("ERROR: Failed to generate MASM for right operand\n");
                return false;
            }
            
            /* Restore left operand and perform operation */
            masm_append_line(ctx, "    pop rbx         ; Restore left operand");
            
            switch (node->data.binary_op.op) {
                case BINOP_ADD:
                    masm_append_line(ctx, "    add rax, rbx    ; Addition");
                    break;
                case BINOP_SUB:
                    masm_append_line(ctx, "    sub rbx, rax    ; Subtraction");
                    masm_append_line(ctx, "    mov rax, rbx    ; Move result to rax");
                    break;
                case BINOP_MUL:
                    masm_append_line(ctx, "    imul rax, rbx   ; Multiplication");
                    break;
                case BINOP_DIV:
                    masm_append_line(ctx, "    xchg rax, rbx   ; Swap operands");
                    masm_append_line(ctx, "    cqo             ; Sign extend rax to rdx:rax");
                    masm_append_line(ctx, "    idiv rbx        ; Division");
                    break;
                case BINOP_AND_AND: {
                    /* Logical AND: result = left && right */
                    masm_append_line(ctx, "    test rax, rax   ; Test left operand");
                    masm_append_line(ctx, "    jz and_false    ; Jump to false if left is 0");
                    masm_append_line(ctx, "    test rbx, rbx   ; Test right operand");
                    masm_append_line(ctx, "    jz and_false    ; Jump to false if right is 0");
                    masm_append_line(ctx, "    mov rax, 1      ; Both true: result = 1");
                    masm_append_line(ctx, "    jmp and_end     ; Jump to end");
                    masm_append_line(ctx, "and_false:");
                    masm_append_line(ctx, "    mov rax, 0      ; Either false: result = 0");
                    masm_append_line(ctx, "and_end:");
                    break;
                }
                case BINOP_XOR_XOR: {
                    /* Logical XOR: result = left ^^ right (exactly one true) */
                    masm_append_line(ctx, "    test rax, rax   ; Test left operand");
                    masm_append_line(ctx, "    setnz al        ; Set al=1 if left is true, 0 if false");
                    masm_append_line(ctx, "    test rbx, rbx   ; Test right operand");
                    masm_append_line(ctx, "    setnz bl        ; Set bl=1 if right is true, 0 if false");
                    masm_append_line(ctx, "    xor al, bl      ; XOR the boolean values");
                    masm_append_line(ctx, "    movzx rax, al   ; Zero-extend result to rax");
                    break;
                }
                case BINOP_OR_OR: {
                    /* Logical OR: result = left || right */
                    masm_append_line(ctx, "    test rax, rax   ; Test left operand");
                    masm_append_line(ctx, "    jnz or_true     ; Jump to true if left is non-zero");
                    masm_append_line(ctx, "    test rbx, rbx   ; Test right operand");
                    masm_append_line(ctx, "    jnz or_true     ; Jump to true if right is non-zero");
                    masm_append_line(ctx, "    mov rax, 0      ; Both false: result = 0");
                    masm_append_line(ctx, "    jmp or_end      ; Jump to end");
                    masm_append_line(ctx, "or_true:");
                    masm_append_line(ctx, "    mov rax, 1      ; Either true: result = 1");
                    masm_append_line(ctx, "or_end:");
                    break;
                }
                default:
                    printf("WARNING: Unhandled binary operator %d\n", node->data.binary_op.op);
                    masm_append_line(ctx, "    mov rax, rbx    ; Default: use left operand");
                    break;
            }
            return true;
        }
            
        case NODE_IF_STMT: {
            /* Generate if statement */
            printf("DEBUG: Generating MASM if statement\n");
            
            /* Generate unique labels */
            static I64 if_label_counter = 0;
            if_label_counter++;
            char else_label[64], end_label[64];
            snprintf(else_label, sizeof(else_label), "if_else_%d", (int)if_label_counter);
            snprintf(end_label, sizeof(end_label), "if_end_%d", (int)if_label_counter);
            
            /* Generate condition evaluation */
            masm_append_line(ctx, "; If condition evaluation");
            if (!masm_generate_ast_node(ctx, node->data.if_stmt.condition)) {
                printf("ERROR: Failed to generate MASM for if condition\n");
                return false;
            }
            
            /* Test condition and jump to else if false */
            masm_append_line(ctx, "    test rax, rax   ; Test condition");
            if (node->data.if_stmt.else_stmt) {
                char jz_instr[64];
                snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to else if false", else_label);
                masm_append_line(ctx, jz_instr);
            } else {
                char jz_instr[64];
                snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to end if false", end_label);
                masm_append_line(ctx, jz_instr);
            }
            
            /* Generate then statement */
            masm_append_line(ctx, "; Then statement");
            if (!masm_generate_ast_node(ctx, node->data.if_stmt.then_stmt)) {
                printf("ERROR: Failed to generate MASM for then statement\n");
                return false;
            }
            
            /* Jump to end if we have else clause */
            if (node->data.if_stmt.else_stmt) {
                char jmp_instr[64];
                snprintf(jmp_instr, sizeof(jmp_instr), "    jmp %s         ; Jump to end", end_label);
                masm_append_line(ctx, jmp_instr);
                char else_label_line[64];
                snprintf(else_label_line, sizeof(else_label_line), "%s:", else_label);
                masm_append_line(ctx, else_label_line);
                
                /* Generate else statement */
                masm_append_line(ctx, "; Else statement");
                if (!masm_generate_ast_node(ctx, node->data.if_stmt.else_stmt)) {
                    printf("ERROR: Failed to generate MASM for else statement\n");
                    return false;
                }
            }
            
            char end_label_line[64];
            snprintf(end_label_line, sizeof(end_label_line), "%s:", end_label);
            masm_append_line(ctx, end_label_line);
            return true;
        }
            
        case NODE_WHILE_STMT: {
            /* Generate while statement */
            printf("DEBUG: Generating MASM while statement\n");
            
            /* Generate unique labels */
            static I64 while_label_counter = 0;
            while_label_counter++;
            char loop_label[64], end_label[64];
            snprintf(loop_label, sizeof(loop_label), "while_loop_%d", (int)while_label_counter);
            snprintf(end_label, sizeof(end_label), "while_end_%d", (int)while_label_counter);
            
            /* Generate loop start label */
            char loop_label_line[64];
            snprintf(loop_label_line, sizeof(loop_label_line), "%s:", loop_label);
            masm_append_line(ctx, loop_label_line);
            
            /* Generate condition evaluation */
            masm_append_line(ctx, "; While condition evaluation");
            if (!masm_generate_ast_node(ctx, node->data.while_stmt.condition)) {
                printf("ERROR: Failed to generate MASM for while condition\n");
                return false;
            }
            
            /* Test condition and jump to end if false */
            masm_append_line(ctx, "    test rax, rax   ; Test condition");
            char jz_instr[64];
            snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to end if false", end_label);
            masm_append_line(ctx, jz_instr);
            
            /* Generate loop body */
            masm_append_line(ctx, "; While loop body");
            if (!masm_generate_ast_node(ctx, node->data.while_stmt.body_stmt)) {
                printf("ERROR: Failed to generate MASM for while body\n");
                return false;
            }
            
            /* Jump back to loop start */
            char jmp_instr[64];
            snprintf(jmp_instr, sizeof(jmp_instr), "    jmp %s         ; Jump back to loop start", loop_label);
            masm_append_line(ctx, jmp_instr);
            
            /* Generate end label */
            char end_label_line[64];
            snprintf(end_label_line, sizeof(end_label_line), "%s:", end_label);
            masm_append_line(ctx, end_label_line);
            return true;
        }
            
        case NODE_SUB_INT_ACCESS: {
            /* Generate sub-int access (i.u16[1]) */
            printf("DEBUG: Generating MASM sub-int access\n");
            
            /* Generate base object address */
            if (!masm_generate_ast_node(ctx, node->data.sub_int_access.base_object)) {
                printf("ERROR: Failed to generate MASM for sub-int access base object\n");
                return false;
            }
            
            /* Save base object address */
            masm_append_line(ctx, "    push rax        ; Save base object address");
            
            /* Generate index expression */
            if (!masm_generate_ast_node(ctx, node->data.sub_int_access.index)) {
                printf("ERROR: Failed to generate MASM for sub-int access index\n");
                return false;
            }
            
            /* Calculate offset: index * member_size */
            I64 member_size = node->data.sub_int_access.member_size;
            if (member_size > 1) {
                char mul_instr[64];
                snprintf(mul_instr, sizeof(mul_instr), "    imul rax, %ld    ; Multiply index by member size", (long)member_size);
                masm_append_line(ctx, mul_instr);
            }
            
            /* Add offset to base address */
            masm_append_line(ctx, "    pop rbx         ; Restore base object address");
            masm_append_line(ctx, "    add rbx, rax    ; Add offset to base address");
            
            /* Load the value from memory with appropriate size */
            U8 *member_type = node->data.sub_int_access.member_type;
            if (member_type) {
                if (strcmp(member_type, "i8") == 0 || strcmp(member_type, "u8") == 0) {
                    masm_append_line(ctx, "    movzx rax, byte [rbx]    ; Load 8-bit value");
                } else if (strcmp(member_type, "i16") == 0 || strcmp(member_type, "u16") == 0) {
                    if (strcmp(member_type, "i16") == 0) {
                        masm_append_line(ctx, "    movsx rax, word [rbx]    ; Load 16-bit signed value");
                    } else {
                        masm_append_line(ctx, "    movzx rax, word [rbx]    ; Load 16-bit unsigned value");
                    }
                } else if (strcmp(member_type, "i32") == 0 || strcmp(member_type, "u32") == 0) {
                    if (strcmp(member_type, "i32") == 0) {
                        masm_append_line(ctx, "    movsxd rax, dword [rbx]  ; Load 32-bit signed value");
                    } else {
                        masm_append_line(ctx, "    mov eax, dword [rbx]     ; Load 32-bit unsigned value");
                    }
                } else {
                    masm_append_line(ctx, "    mov rax, [rbx]           ; Load default value");
                }
            } else {
                masm_append_line(ctx, "    mov rax, [rbx]           ; Load value");
            }
            
            return true;
        }
            
        case NODE_UNION_MEMBER_ACCESS: {
            /* Generate union member access (union_var.member[index]) */
            printf("DEBUG: Generating MASM union member access\n");
            
            /* Generate union object address */
            if (!masm_generate_ast_node(ctx, node->data.union_member_access.union_object)) {
                printf("ERROR: Failed to generate MASM for union member access object\n");
                return false;
            }
            
            /* Save union object address */
            masm_append_line(ctx, "    push rax        ; Save union object address");
            
            /* Generate index expression */
            if (!masm_generate_ast_node(ctx, node->data.union_member_access.index)) {
                printf("ERROR: Failed to generate MASM for union member access index\n");
                return false;
            }
            
            /* Calculate offset: index * member_size */
            I64 member_size = node->data.union_member_access.member_size;
            if (member_size > 1) {
                char mul_instr[64];
                snprintf(mul_instr, sizeof(mul_instr), "    imul rax, %ld    ; Multiply index by member size", (long)member_size);
                masm_append_line(ctx, mul_instr);
            }
            
            /* Add offset to union address */
            masm_append_line(ctx, "    pop rbx         ; Restore union object address");
            masm_append_line(ctx, "    add rbx, rax    ; Add offset to union address");
            
            /* Load the value from memory */
            masm_append_line(ctx, "    mov rax, [rbx]  ; Load union member value");
            
            return true;
        }
            
        case NODE_TYPE_PREFIXED_UNION: {
            /* Type-prefixed union declaration - no code generation needed */
            printf("DEBUG: Processing type-prefixed union declaration: %s\n", 
                   node->data.type_prefixed_union.union_name ? (char*)node->data.type_prefixed_union.union_name : "unnamed");
            return true;
        }
            
        case NODE_RANGE_COMPARISON: {
            /* Generate range comparison (5<i<j+1<20) */
            printf("DEBUG: Generating range comparison with %ld expressions\n", node->data.range_comparison.expression_count);
            
            /* Generate unique labels for the range comparison */
            static I64 range_label_counter = 0;
            range_label_counter++;
            char true_label[64], false_label[64], end_label[64];
            snprintf(true_label, sizeof(true_label), "range_true_%d", (int)range_label_counter);
            snprintf(false_label, sizeof(false_label), "range_false_%d", (int)range_label_counter);
            snprintf(end_label, sizeof(end_label), "range_end_%d", (int)range_label_counter);
            
            /* Generate all expressions first and store them on the stack */
            ASTNode *expr = node->data.range_comparison.expressions;
            I64 expr_count = 0;
            while (expr) {
                if (!masm_generate_ast_node(ctx, expr)) {
                    printf("ERROR: Failed to generate MASM for range expression %ld\n", expr_count);
                    return false;
                }
                masm_append_line(ctx, "    push rax        ; Save expression result");
                expr = expr->next;
                expr_count++;
            }
            
            /* Generate comparison operations */
            ASTNode *op = node->data.range_comparison.operators;
            expr_count = 0;
            
            /* Load first expression */
            masm_append_line(ctx, "    pop rax         ; Load first expression");
            
            while (op && expr_count < node->data.range_comparison.expression_count - 1) {
                /* Load next expression */
                masm_append_line(ctx, "    pop rbx         ; Load next expression");
                
                /* Perform comparison based on operator */
                switch (op->data.binary_op.op) {
                    case BINOP_LT: {
                        char jge_instr[128];
                        snprintf(jge_instr, sizeof(jge_instr), "    jge %s    ; Jump to false if not <", false_label);
                        masm_append_line(ctx, "    cmp rax, rbx    ; Compare <");
                        masm_append_line(ctx, jge_instr);
                        break;
                    }
                    case BINOP_GT: {
                        char jle_instr[128];
                        snprintf(jle_instr, sizeof(jle_instr), "    jle %s    ; Jump to false if not >", false_label);
                        masm_append_line(ctx, "    cmp rax, rbx    ; Compare >");
                        masm_append_line(ctx, jle_instr);
                        break;
                    }
                    case BINOP_LE: {
                        char jg_instr[128];
                        snprintf(jg_instr, sizeof(jg_instr), "    jg %s     ; Jump to false if not <=", false_label);
                        masm_append_line(ctx, "    cmp rax, rbx    ; Compare <=");
                        masm_append_line(ctx, jg_instr);
                        break;
                    }
                    case BINOP_GE: {
                        char jl_instr[128];
                        snprintf(jl_instr, sizeof(jl_instr), "    jl %s     ; Jump to false if not >=", false_label);
                        masm_append_line(ctx, "    cmp rax, rbx    ; Compare >=");
                        masm_append_line(ctx, jl_instr);
                        break;
                    }
                    default: {
                        char jne_instr[128];
                        snprintf(jne_instr, sizeof(jne_instr), "    jne %s    ; Jump to false if not equal", false_label);
                        printf("WARNING: Unhandled range comparison operator %d\n", op->data.binary_op.op);
                        masm_append_line(ctx, "    cmp rax, rbx    ; Default comparison");
                        masm_append_line(ctx, jne_instr);
                        break;
                    }
                }
                
                /* Move to next expression for next comparison */
                masm_append_line(ctx, "    mov rax, rbx    ; Move to next expression");
                
                op = op->next;
                expr_count++;
            }
            
            /* All comparisons passed - set result to true */
            masm_append_line(ctx, "    mov rax, 1      ; Range comparison result: true");
            char jmp_end_instr[128];
            snprintf(jmp_end_instr, sizeof(jmp_end_instr), "    jmp %s     ; Jump to end", end_label);
            masm_append_line(ctx, jmp_end_instr);
            
            /* False label */
            char false_label_line[64];
            snprintf(false_label_line, sizeof(false_label_line), "%s:", false_label);
            masm_append_line(ctx, false_label_line);
            masm_append_line(ctx, "    mov rax, 0      ; Range comparison result: false");
            
            /* End label */
            char end_label_line[64];
            snprintf(end_label_line, sizeof(end_label_line), "%s:", end_label);
            masm_append_line(ctx, end_label_line);
            
            printf("DEBUG: Range comparison assembly generation completed\n");
            return true;
        }
            
        default:
            printf("WARNING: Unhandled AST node type %d in MASM generation\n", node->type);
            return true;
    }
}

Bool masm_generate_assembly_from_ast(MASMContext *ctx, ASTNode *ast, const char *filename) {
    if (!ctx || !ast || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly from AST: %s\n", filename);
    
    /* Generate MASM assembly from AST */
    if (!masm_generate_header(ctx)) return false;
    
    /* Generate main function with all global statements */
    if (!masm_generate_user_main_function(ctx, ast)) {
        printf("ERROR: Failed to generate main function\n");
        return false;
    }
    
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated from AST: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Utility Functions
 */

void masm_print_debug_info(MASMContext *ctx) {
    if (!ctx) return;
    
    printf("MASM Debug Information:\n");
    printf("  Output size: %zu bytes\n", ctx->output_size);
    printf("  Buffer capacity: %zu bytes\n", ctx->output_capacity);
    printf("  Indent level: %d\n", ctx->indent_level);
}
