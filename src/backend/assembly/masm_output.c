/*
 * MASM Assembly Output Module
 * Generates Microsoft Macro Assembler (MASM) assembly code for Windows x64
 */

#include "masm_output.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * MASM Assembly Context
 */

MASMContext* masm_context_new(AssemblyContext *asm_ctx) {
    MASMContext *ctx = malloc(sizeof(MASMContext));
    if (!ctx) return NULL;
    
    memset(ctx, 0, sizeof(MASMContext));
    ctx->asm_ctx = asm_ctx;
    
    /* Initialize output buffer */
    ctx->output_capacity = 8192;  /* Start with 8KB */
    ctx->output_buffer = malloc(ctx->output_capacity);
    if (!ctx->output_buffer) {
        free(ctx);
        return NULL;
    }
    
    ctx->output_size = 0;
    ctx->indent_level = 0;
    
    return ctx;
}

void masm_context_free(MASMContext *ctx) {
    if (!ctx) return;
    
    if (ctx->output_buffer) free(ctx->output_buffer);
    free(ctx);
}

/*
 * Output Buffer Management
 */

static Bool masm_ensure_capacity(MASMContext *ctx, size_t needed) {
    if (ctx->output_size + needed <= ctx->output_capacity) {
        return true;
    }
    
    size_t new_capacity = ctx->output_capacity * 2;
    while (new_capacity < ctx->output_size + needed) {
        new_capacity *= 2;
    }
    
    char *new_buffer = realloc(ctx->output_buffer, new_capacity);
    if (!new_buffer) return false;
    
    ctx->output_buffer = new_buffer;
    ctx->output_capacity = new_capacity;
    
    return true;
}

static Bool masm_append_string(MASMContext *ctx, const char *str) {
    size_t len = strlen(str);
    if (!masm_ensure_capacity(ctx, len + 1)) return false;
    
    strcpy(ctx->output_buffer + ctx->output_size, str);
    ctx->output_size += len;
    
    return true;
}

static Bool masm_append_line(MASMContext *ctx, const char *line) {
    /* Add indentation */
    for (int i = 0; i < ctx->indent_level; i++) {
        if (!masm_append_string(ctx, "    ")) return false;
    }
    
    /* Add the line */
    if (!masm_append_string(ctx, line)) return false;
    
    /* Add newline */
    if (!masm_append_string(ctx, "\n")) return false;
    
    return true;
}

/*
 * MASM Assembly Generation
 */

Bool masm_generate_header(MASMContext *ctx) {
    if (!ctx) return false;
    
    /* MASM header for x64 Windows */
    masm_append_line(ctx, "; Generated by SchismC - MASM Assembly Output");
    masm_append_line(ctx, "; Target: Windows x64");
    masm_append_line(ctx, "");
    masm_append_line(ctx, ".code");
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; External functions");
    masm_append_line(ctx, "extrn ExitProcess:PROC");
    masm_append_line(ctx, "extrn GetStdHandle:PROC");
    masm_append_line(ctx, "extrn WriteConsoleA:PROC");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_entry_point(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "; Windows entry point");
    masm_append_line(ctx, "main PROC");
    ctx->indent_level++;
    
    /* x64 calling convention setup */
    masm_append_line(ctx, "    sub rsp, 28h        ; Allocate shadow space + align");
    masm_append_line(ctx, "    call user_main      ; Call user code");
    masm_append_line(ctx, "    mov rcx, rax        ; Exit code in rcx");
    masm_append_line(ctx, "    call ExitProcess    ; Exit with return code");
    masm_append_line(ctx, "    add rsp, 28h        ; Restore stack");
    masm_append_line(ctx, "    ret");
    
    ctx->indent_level--;
    masm_append_line(ctx, "main ENDP");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_user_main(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "; User main function");
    masm_append_line(ctx, "user_main PROC");
    ctx->indent_level++;
    
    /* Simple return 0 for now */
    masm_append_line(ctx, "    mov rax, 0          ; Return 0");
    masm_append_line(ctx, "    ret");
    
    ctx->indent_level--;
    masm_append_line(ctx, "user_main ENDP");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_footer(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "END");
    
    return true;
}

/*
 * Main MASM Generation Function
 */

Bool masm_generate_assembly(MASMContext *ctx, const char *filename) {
    if (!ctx || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly file: %s\n", filename);
    
    /* Generate MASM assembly */
    if (!masm_generate_header(ctx)) return false;
    if (!masm_generate_entry_point(ctx)) return false;
    if (!masm_generate_user_main(ctx)) return false;
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Function-related MASM Generation
 */

Bool masm_generate_function_declaration(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_FUNCTION) return false;
    
    printf("DEBUG: Generating MASM function declaration: %s\n", 
           node->data.function.name ? (char*)node->data.function.name : "unknown");
    
    /* Generate function signature */
    char func_sig[256];
    snprintf(func_sig, sizeof(func_sig), "%s PROC", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    
    masm_append_line(ctx, "");
    masm_append_line(ctx, func_sig);
    ctx->indent_level++;
    
    /* Generate function prologue */
    masm_append_line(ctx, "; Function prologue");
    masm_append_line(ctx, "    push rbp        ; Save caller's frame pointer");
    masm_append_line(ctx, "    mov rbp, rsp    ; Set up new frame pointer");
    
    /* Calculate local variable space */
    I64 local_space = 32; /* Default shadow space */
    /* TODO: Count parameters from parameter list */
    /* For now, use default shadow space */
    
    char sub_instr[64];
    snprintf(sub_instr, sizeof(sub_instr), "    sub rsp, %ldh    ; Allocate local space", local_space);
    masm_append_line(ctx, sub_instr);
    masm_append_line(ctx, "");
    
    /* Generate function body */
    if (node->data.function.body) {
        masm_append_line(ctx, "; Function body");
        if (!masm_generate_ast_node(ctx, node->data.function.body)) {
            printf("ERROR: Failed to generate MASM for function body\n");
            return false;
        }
    }
    
    /* Generate function epilogue */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Function epilogue");
    masm_append_line(ctx, "    mov rsp, rbp    ; Restore stack pointer");
    masm_append_line(ctx, "    pop rbp         ; Restore caller's frame pointer");
    masm_append_line(ctx, "    ret             ; Return to caller");
    
    ctx->indent_level--;
    
    /* Generate function end */
    char func_end[256];
    snprintf(func_end, sizeof(func_end), "%s ENDP", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    masm_append_line(ctx, func_end);
    
    printf("DEBUG: Generated MASM function declaration successfully\n");
    return true;
}

Bool masm_generate_function_call(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_CALL) return false;
    
    printf("DEBUG: Generating MASM function call: %s\n", 
           node->data.call.name ? (char*)node->data.call.name : "unknown");
    
    I64 arg_count = node->data.call.arg_count;
    
    /* Allocate shadow space if we have arguments */
    if (arg_count > 0) {
        masm_append_line(ctx, "; Allocate shadow space");
        masm_append_line(ctx, "    sub rsp, 20h    ; 32 bytes shadow space");
    }
    
    /* Generate argument passing */
    if (node->data.call.arguments && node->data.call.arguments->data.block.statements) {
        ASTNode *arg = node->data.call.arguments->data.block.statements;
        I64 arg_index = 0;
        
        masm_append_line(ctx, "; Pass arguments");
        
        while (arg && arg_index < arg_count) {
            if (arg_index < 4) {
                /* First 4 arguments go in registers */
                const char *reg_names[] = {"rcx", "rdx", "r8", "r9"};
                
                /* Generate code to evaluate argument and move to register */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for argument %lld\n", arg_index);
                    return false;
                }
                
                /* Move result to appropriate register */
                char mov_instr[64];
                snprintf(mov_instr, sizeof(mov_instr), "    mov %s, rax    ; Argument %ld", 
                         reg_names[arg_index], arg_index);
                masm_append_line(ctx, mov_instr);
                
            } else {
                /* Additional arguments go on stack */
                /* Generate code to evaluate argument */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for stack argument %lld\n", arg_index);
                    return false;
                }
                
                /* Push argument onto stack */
                masm_append_line(ctx, "    push rax        ; Stack argument");
            }
            
            arg = arg->next;
            arg_index++;
        }
    }
    
    /* Generate function call */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Call function");
    char call_instr[128];
    snprintf(call_instr, sizeof(call_instr), "    call %s", 
             node->data.call.name ? (char*)node->data.call.name : "unknown_func");
    masm_append_line(ctx, call_instr);
    
    /* Clean up stack arguments */
    if (arg_count > 4) {
        I64 stack_args = arg_count - 4;
        char cleanup_instr[64];
        snprintf(cleanup_instr, sizeof(cleanup_instr), "    add rsp, %ldh    ; Clean up stack arguments", 
                 stack_args * 8);
        masm_append_line(ctx, cleanup_instr);
    }
    
    /* Restore shadow space */
    if (arg_count > 0) {
        masm_append_line(ctx, "    add rsp, 20h    ; Restore shadow space");
    }
    
    printf("DEBUG: Generated MASM function call successfully\n");
    return true;
}

Bool masm_generate_return_statement(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_RETURN) return false;
    
    printf("DEBUG: Generating MASM return statement\n");
    
    /* Check if we have a return value or expression */
    if (node->data.return_stmt.return_value != 0) {
        /* Simple return value (integer literal) */
        I64 return_value = node->data.return_stmt.return_value;
        
        char mov_instr[64];
        snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Return value", return_value);
        masm_append_line(ctx, mov_instr);
        
    } else if (node->data.return_stmt.expression) {
        /* Complex return expression */
        masm_append_line(ctx, "; Evaluate return expression");
        if (!masm_generate_ast_node(ctx, node->data.return_stmt.expression)) {
            printf("ERROR: Failed to generate MASM for return expression\n");
            return false;
        }
        masm_append_line(ctx, "; Result is in rax");
        
    } else {
        /* No return value - just return */
        masm_append_line(ctx, "; Return void");
    }
    
    printf("DEBUG: Generated MASM return statement successfully\n");
    return true;
}

Bool masm_generate_ast_node(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node) return false;
    
    switch (node->type) {
        case NODE_FUNCTION:
            return masm_generate_function_declaration(ctx, node);
            
        case NODE_CALL:
            return masm_generate_function_call(ctx, node);
            
        case NODE_RETURN:
            return masm_generate_return_statement(ctx, node);
            
        case NODE_INTEGER: {
            /* Generate immediate value */
            char mov_instr[64];
            snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Integer literal", 
                     node->data.literal.i64_value);
            masm_append_line(ctx, mov_instr);
            return true;
        }
            
        case NODE_BLOCK:
            /* Generate block statements */
            if (node->data.block.statements) {
                ASTNode *stmt = node->data.block.statements;
                while (stmt) {
                    if (!masm_generate_ast_node(ctx, stmt)) {
                        printf("ERROR: Failed to generate MASM for block statement\n");
                        return false;
                    }
                    stmt = stmt->next;
                }
            }
            return true;
            
        default:
            printf("WARNING: Unhandled AST node type %d in MASM generation\n", node->type);
            return true;
    }
}

Bool masm_generate_assembly_from_ast(MASMContext *ctx, ASTNode *ast, const char *filename) {
    if (!ctx || !ast || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly from AST: %s\n", filename);
    
    /* Generate MASM assembly from AST */
    if (!masm_generate_header(ctx)) return false;
    
    /* Generate functions from AST */
    ASTNode *child = ast->children;
    while (child) {
        if (child->type == NODE_FUNCTION) {
            if (!masm_generate_function_declaration(ctx, child)) {
                printf("ERROR: Failed to generate MASM for function\n");
                return false;
            }
        }
        child = child->next;
    }
    
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated from AST: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Utility Functions
 */

void masm_print_debug_info(MASMContext *ctx) {
    if (!ctx) return;
    
    printf("MASM Debug Information:\n");
    printf("  Output size: %zu bytes\n", ctx->output_size);
    printf("  Buffer capacity: %zu bytes\n", ctx->output_capacity);
    printf("  Indent level: %d\n", ctx->indent_level);
}
