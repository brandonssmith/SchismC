/*
 * MASM Assembly Output Module
 * Generates Microsoft Macro Assembler (MASM) assembly code for Windows x64
 */

#include "masm_output.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * MASM Assembly Context
 */

MASMContext* masm_context_new(AssemblyContext *asm_ctx) {
    MASMContext *ctx = malloc(sizeof(MASMContext));
    if (!ctx) return NULL;
    
    memset(ctx, 0, sizeof(MASMContext));
    ctx->asm_ctx = asm_ctx;
    
    /* Initialize output buffer */
    ctx->output_capacity = 8192;  /* Start with 8KB */
    ctx->output_buffer = malloc(ctx->output_capacity);
    if (!ctx->output_buffer) {
        free(ctx);
        return NULL;
    }
    
    ctx->output_size = 0;
    ctx->indent_level = 0;
    ctx->string_counter = 0;
    
    return ctx;
}

void masm_context_free(MASMContext *ctx) {
    if (!ctx) return;
    
    if (ctx->output_buffer) free(ctx->output_buffer);
    free(ctx);
}

/*
 * Output Buffer Management
 */

static Bool masm_ensure_capacity(MASMContext *ctx, size_t needed) {
    if (ctx->output_size + needed <= ctx->output_capacity) {
        return true;
    }
    
    size_t new_capacity = ctx->output_capacity * 2;
    while (new_capacity < ctx->output_size + needed) {
        new_capacity *= 2;
    }
    
    char *new_buffer = realloc(ctx->output_buffer, new_capacity);
    if (!new_buffer) return false;
    
    ctx->output_buffer = new_buffer;
    ctx->output_capacity = new_capacity;
    
    return true;
}

static Bool masm_append_string(MASMContext *ctx, const char *str) {
    size_t len = strlen(str);
    if (!masm_ensure_capacity(ctx, len + 1)) return false;
    
    strcpy(ctx->output_buffer + ctx->output_size, str);
    ctx->output_size += len;
    
    return true;
}

static Bool masm_append_line(MASMContext *ctx, const char *line) {
    /* Add indentation */
    for (int i = 0; i < ctx->indent_level; i++) {
        if (!masm_append_string(ctx, "    ")) return false;
    }
    
    /* Add the line */
    if (!masm_append_string(ctx, line)) return false;
    
    /* Add newline */
    if (!masm_append_string(ctx, "\n")) return false;
    
    return true;
}

/*
 * MASM Assembly Generation
 */

Bool masm_generate_user_main_function(MASMContext *ctx, ASTNode *ast) {
    if (!ctx || !ast) return false;
    
    /* Generate user_main function that contains all global statements */
    masm_append_line(ctx, "; User main function");
    masm_append_line(ctx, "user_main PROC");
    ctx->indent_level++;
    
    /* Process all global statements */
    ASTNode *child = ast->children;
    while (child) {
        if (!masm_generate_ast_node(ctx, child)) {
            printf("ERROR: Failed to generate MASM for AST node type %d\n", child->type);
            return false;
        }
        child = child->next;
    }
    
    /* Return 0 */
    masm_append_line(ctx, "mov rax, 0          ; Return 0");
    masm_append_line(ctx, "ret");
    
    ctx->indent_level--;
    masm_append_line(ctx, "user_main ENDP");
    
    return true;
}

Bool masm_generate_header(MASMContext *ctx) {
    if (!ctx) return false;
    
    /* MASM header for x64 Windows */
    masm_append_line(ctx, "; Generated by SchismC - MASM Assembly Output");
    masm_append_line(ctx, "; Target: Windows x64");
    masm_append_line(ctx, "");
    masm_append_line(ctx, ".code");
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; External functions");
    masm_append_line(ctx, "extrn ExitProcess:PROC");
    masm_append_line(ctx, "extrn GetStdHandle:PROC");
    masm_append_line(ctx, "extrn WriteConsoleA:PROC");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_entry_point(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "; Windows entry point");
    masm_append_line(ctx, "main PROC");
    ctx->indent_level++;
    
    /* x64 calling convention setup */
    masm_append_line(ctx, "    sub rsp, 28h        ; Allocate shadow space + align");
    masm_append_line(ctx, "    call user_main      ; Call user code");
    masm_append_line(ctx, "    mov rcx, rax        ; Exit code in rcx");
    masm_append_line(ctx, "    call ExitProcess    ; Exit with return code");
    masm_append_line(ctx, "    add rsp, 28h        ; Restore stack");
    masm_append_line(ctx, "    ret");
    
    ctx->indent_level--;
    masm_append_line(ctx, "main ENDP");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_user_main(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "; User main function");
    masm_append_line(ctx, "user_main PROC");
    ctx->indent_level++;
    
    /* Simple return 0 for now */
    masm_append_line(ctx, "    mov rax, 0          ; Return 0");
    masm_append_line(ctx, "    ret");
    
    ctx->indent_level--;
    masm_append_line(ctx, "user_main ENDP");
    masm_append_line(ctx, "");
    
    return true;
}

Bool masm_generate_footer(MASMContext *ctx) {
    if (!ctx) return false;
    
    masm_append_line(ctx, "END");
    
    return true;
}

/*
 * Main MASM Generation Function
 */

Bool masm_generate_assembly(MASMContext *ctx, const char *filename) {
    if (!ctx || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly file: %s\n", filename);
    
    /* Generate MASM assembly */
    if (!masm_generate_header(ctx)) return false;
    if (!masm_generate_entry_point(ctx)) return false;
    if (!masm_generate_user_main(ctx)) return false;
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Function-related MASM Generation
 */

Bool masm_generate_function_declaration(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_FUNCTION) return false;
    
    printf("DEBUG: Generating MASM function declaration: %s\n", 
           node->data.function.name ? (char*)node->data.function.name : "unknown");
    
    /* Generate function signature */
    char func_sig[256];
    snprintf(func_sig, sizeof(func_sig), "%s PROC", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    
    masm_append_line(ctx, "");
    masm_append_line(ctx, func_sig);
    ctx->indent_level++;
    
    /* Generate function prologue */
    masm_append_line(ctx, "; Function prologue");
    masm_append_line(ctx, "    push rbp        ; Save caller's frame pointer");
    masm_append_line(ctx, "    mov rbp, rsp    ; Set up new frame pointer");
    
    /* Calculate local variable space */
    I64 local_space = 32; /* Default shadow space */
    /* TODO: Count parameters from parameter list */
    /* For now, use default shadow space */
    
    char sub_instr[64];
    snprintf(sub_instr, sizeof(sub_instr), "    sub rsp, %ldh    ; Allocate local space", local_space);
    masm_append_line(ctx, sub_instr);
    masm_append_line(ctx, "");
    
    /* Generate function body */
    if (node->data.function.body) {
        masm_append_line(ctx, "; Function body");
        if (!masm_generate_ast_node(ctx, node->data.function.body)) {
            printf("ERROR: Failed to generate MASM for function body\n");
            return false;
        }
    }
    
    /* Generate function epilogue */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Function epilogue");
    masm_append_line(ctx, "    mov rsp, rbp    ; Restore stack pointer");
    masm_append_line(ctx, "    pop rbp         ; Restore caller's frame pointer");
    masm_append_line(ctx, "    ret             ; Return to caller");
    
    ctx->indent_level--;
    
    /* Generate function end */
    char func_end[256];
    snprintf(func_end, sizeof(func_end), "%s ENDP", 
             node->data.function.name ? (char*)node->data.function.name : "unknown_func");
    masm_append_line(ctx, func_end);
    
    printf("DEBUG: Generated MASM function declaration successfully\n");
    return true;
}

Bool masm_generate_function_call(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_CALL) return false;
    
    printf("DEBUG: Generating MASM function call: %s\n", 
           node->data.call.name ? (char*)node->data.call.name : "unknown");
    
    I64 arg_count = node->data.call.arg_count;
    
    /* Allocate shadow space if we have arguments */
    if (arg_count > 0) {
        masm_append_line(ctx, "; Allocate shadow space");
        masm_append_line(ctx, "    sub rsp, 20h    ; 32 bytes shadow space");
    }
    
    /* Generate argument passing */
    if (node->data.call.arguments && node->data.call.arguments->data.block.statements) {
        ASTNode *arg = node->data.call.arguments->data.block.statements;
        I64 arg_index = 0;
        
        masm_append_line(ctx, "; Pass arguments");
        
        while (arg && arg_index < arg_count) {
            if (arg_index < 4) {
                /* First 4 arguments go in registers */
                const char *reg_names[] = {"rcx", "rdx", "r8", "r9"};
                
                /* Generate code to evaluate argument and move to register */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for argument %lld\n", arg_index);
                    return false;
                }
                
                /* Move result to appropriate register */
                char mov_instr[64];
                snprintf(mov_instr, sizeof(mov_instr), "    mov %s, rax    ; Argument %ld", 
                         reg_names[arg_index], arg_index);
                masm_append_line(ctx, mov_instr);
                
            } else {
                /* Additional arguments go on stack */
                /* Generate code to evaluate argument */
                if (!masm_generate_ast_node(ctx, arg)) {
                    printf("ERROR: Failed to generate MASM for stack argument %lld\n", arg_index);
                    return false;
                }
                
                /* Push argument onto stack */
                masm_append_line(ctx, "    push rax        ; Stack argument");
            }
            
            arg = arg->next;
            arg_index++;
        }
    }
    
    /* Generate function call */
    masm_append_line(ctx, "");
    masm_append_line(ctx, "; Call function");
    char call_instr[128];
    snprintf(call_instr, sizeof(call_instr), "    call %s", 
             node->data.call.name ? (char*)node->data.call.name : "unknown_func");
    masm_append_line(ctx, call_instr);
    
    /* Clean up stack arguments */
    if (arg_count > 4) {
        I64 stack_args = arg_count - 4;
        char cleanup_instr[64];
        snprintf(cleanup_instr, sizeof(cleanup_instr), "    add rsp, %ldh    ; Clean up stack arguments", 
                 stack_args * 8);
        masm_append_line(ctx, cleanup_instr);
    }
    
    /* Restore shadow space */
    if (arg_count > 0) {
        masm_append_line(ctx, "    add rsp, 20h    ; Restore shadow space");
    }
    
    printf("DEBUG: Generated MASM function call successfully\n");
    return true;
}

Bool masm_generate_return_statement(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node || node->type != NODE_RETURN) return false;
    
    printf("DEBUG: Generating MASM return statement\n");
    
    /* Check if we have a return value or expression */
    if (node->data.return_stmt.return_value != 0) {
        /* Simple return value (integer literal) */
        I64 return_value = node->data.return_stmt.return_value;
        
        char mov_instr[64];
        snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Return value", return_value);
        masm_append_line(ctx, mov_instr);
        
    } else if (node->data.return_stmt.expression) {
        /* Complex return expression */
        masm_append_line(ctx, "; Evaluate return expression");
        if (!masm_generate_ast_node(ctx, node->data.return_stmt.expression)) {
            printf("ERROR: Failed to generate MASM for return expression\n");
            return false;
        }
        masm_append_line(ctx, "; Result is in rax");
        
    } else {
        /* No return value - just return */
        masm_append_line(ctx, "; Return void");
    }
    
    printf("DEBUG: Generated MASM return statement successfully\n");
    return true;
}

Bool masm_generate_ast_node(MASMContext *ctx, ASTNode *node) {
    if (!ctx || !node) return false;
    
    switch (node->type) {
        case NODE_FUNCTION:
            return masm_generate_function_declaration(ctx, node);
            
        case NODE_CALL:
            return masm_generate_function_call(ctx, node);
            
        case NODE_RETURN:
            return masm_generate_return_statement(ctx, node);
            
        case NODE_INTEGER: {
            /* Generate immediate value */
            char mov_instr[64];
            snprintf(mov_instr, sizeof(mov_instr), "    mov rax, %ld    ; Integer literal", 
                     node->data.literal.i64_value);
            masm_append_line(ctx, mov_instr);
            return true;
        }
            
        case NODE_STRING: {
            /* Generate string literal - in HolyC, strings are automatically printed */
            printf("DEBUG: masm_generate_ast_node - processing NODE_STRING\n");
            if (node->data.literal.str_value) {
                printf("DEBUG: masm_generate_ast_node - string value: %s\n", node->data.literal.str_value);
                
                /* In HolyC, string literals are automatically printed (sent to Print()) */
                /* Generate assembly to call Print() with the string literal */
                char str_label[64];
                snprintf(str_label, sizeof(str_label), "str_literal_%d", ctx->string_counter);
                
                /* Add string to data section */
                char data_line[256];
                snprintf(data_line, sizeof(data_line), "%s DB \"%s\", 0", str_label, (char*)node->data.literal.str_value);
                masm_append_line(ctx, data_line);
                
                /* Generate call to Print() */
                char load_line[128];
                snprintf(load_line, sizeof(load_line), "lea rax, [%s]", str_label);
                masm_append_line(ctx, load_line);  /* Load string address */
                masm_append_line(ctx, "call Print");  /* Call Print() function */
                
                ctx->string_counter++;  /* Increment counter for next string */
                
                printf("DEBUG: masm_generate_ast_node - generated string print assembly\n");
            } else {
                printf("DEBUG: masm_generate_ast_node - no string value\n");
                masm_append_line(ctx, "; String literal: (null)");
            }
            printf("DEBUG: masm_generate_ast_node - NODE_STRING completed successfully\n");
            return true;
        }
            
        case NODE_BLOCK:
            /* Generate block statements */
            printf("DEBUG: masm_generate_ast_node - processing NODE_BLOCK\n");
            if (node->data.block.statements) {
                ASTNode *stmt = node->data.block.statements;
                int stmt_count = 0;
                while (stmt) {
                    printf("DEBUG: masm_generate_ast_node - processing block statement %d, type %d\n", stmt_count, stmt->type);
                    if (!masm_generate_ast_node(ctx, stmt)) {
                        printf("ERROR: Failed to generate MASM for block statement\n");
                        return false;
                    }
                    stmt = stmt->next;
                    stmt_count++;
                }
                printf("DEBUG: masm_generate_ast_node - processed %d block statements\n", stmt_count);
            } else {
                printf("DEBUG: masm_generate_ast_node - no block statements\n");
            }
            return true;
            
        case NODE_IDENTIFIER: {
            /* Generate variable reference - load from stack frame */
            if (node->data.identifier.name) {
                /* Check if this is a parameter or local variable */
                if (node->data.identifier.stack_offset >= 0) {
                    /* Local variable or parameter - load from stack frame */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov rax, [rbp%+ld]    ; Load variable %s", 
                             node->data.identifier.stack_offset, (char*)node->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                } else {
                    /* Global variable - load from data section */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov rax, [%s]    ; Load global variable %s", 
                             (char*)node->data.identifier.name, (char*)node->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                }
            } else {
                /* Fallback for unnamed identifier */
                masm_append_line(ctx, "    mov rax, 0    ; Unnamed identifier");
            }
            return true;
        }
            
        case NODE_VARIABLE: {
            /* Variable declaration - no code generation needed, just scope management */
            printf("DEBUG: Processing variable declaration: %s\n", 
                   node->data.identifier.name ? (char*)node->data.identifier.name : "unnamed");
            return true;
        }
            
        case NODE_ASSIGNMENT: {
            /* Generate assignment - evaluate right side, store in left side */
            if (!masm_generate_ast_node(ctx, node->data.assignment.right)) {
                printf("ERROR: Failed to generate MASM for assignment right-hand side\n");
                return false;
            }
            
            /* Store result in the variable on the left side */
            if (node->data.assignment.left && node->data.assignment.left->data.identifier.name) {
                if (node->data.assignment.left->data.identifier.stack_offset >= 0) {
                    /* Local variable or parameter - store in stack frame */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov [rbp%+ld], rax    ; Store in variable %s", 
                             node->data.assignment.left->data.identifier.stack_offset, 
                             (char*)node->data.assignment.left->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                } else {
                    /* Global variable - store in data section */
                    char mov_instr[128];
                    snprintf(mov_instr, sizeof(mov_instr), "    mov [%s], rax    ; Store in global variable %s", 
                             (char*)node->data.assignment.left->data.identifier.name,
                             (char*)node->data.assignment.left->data.identifier.name);
                    masm_append_line(ctx, mov_instr);
                }
            }
            return true;
        }
            
        case NODE_BINARY_OP: {
            /* Generate binary operation */
            if (!masm_generate_ast_node(ctx, node->data.binary_op.left)) {
                printf("ERROR: Failed to generate MASM for left operand\n");
                return false;
            }
            
            /* Save left operand */
            masm_append_line(ctx, "    push rax        ; Save left operand");
            
            /* Generate right operand */
            if (!masm_generate_ast_node(ctx, node->data.binary_op.right)) {
                printf("ERROR: Failed to generate MASM for right operand\n");
                return false;
            }
            
            /* Restore left operand and perform operation */
            masm_append_line(ctx, "    pop rbx         ; Restore left operand");
            
            switch (node->data.binary_op.op) {
                case BINOP_ADD:
                    masm_append_line(ctx, "    add rax, rbx    ; Addition");
                    break;
                case BINOP_SUB:
                    masm_append_line(ctx, "    sub rbx, rax    ; Subtraction");
                    masm_append_line(ctx, "    mov rax, rbx    ; Move result to rax");
                    break;
                case BINOP_MUL:
                    masm_append_line(ctx, "    imul rax, rbx   ; Multiplication");
                    break;
                case BINOP_DIV:
                    masm_append_line(ctx, "    xchg rax, rbx   ; Swap operands");
                    masm_append_line(ctx, "    cqo             ; Sign extend rax to rdx:rax");
                    masm_append_line(ctx, "    idiv rbx        ; Division");
                    break;
                default:
                    printf("WARNING: Unhandled binary operator %d\n", node->data.binary_op.op);
                    masm_append_line(ctx, "    mov rax, rbx    ; Default: use left operand");
                    break;
            }
            return true;
        }
            
        case NODE_IF_STMT: {
            /* Generate if statement */
            printf("DEBUG: Generating MASM if statement\n");
            
            /* Generate unique labels */
            static I64 if_label_counter = 0;
            if_label_counter++;
            char else_label[64], end_label[64];
            snprintf(else_label, sizeof(else_label), "if_else_%d", (int)if_label_counter);
            snprintf(end_label, sizeof(end_label), "if_end_%d", (int)if_label_counter);
            
            /* Generate condition evaluation */
            masm_append_line(ctx, "; If condition evaluation");
            if (!masm_generate_ast_node(ctx, node->data.if_stmt.condition)) {
                printf("ERROR: Failed to generate MASM for if condition\n");
                return false;
            }
            
            /* Test condition and jump to else if false */
            masm_append_line(ctx, "    test rax, rax   ; Test condition");
            if (node->data.if_stmt.else_stmt) {
                char jz_instr[64];
                snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to else if false", else_label);
                masm_append_line(ctx, jz_instr);
            } else {
                char jz_instr[64];
                snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to end if false", end_label);
                masm_append_line(ctx, jz_instr);
            }
            
            /* Generate then statement */
            masm_append_line(ctx, "; Then statement");
            if (!masm_generate_ast_node(ctx, node->data.if_stmt.then_stmt)) {
                printf("ERROR: Failed to generate MASM for then statement\n");
                return false;
            }
            
            /* Jump to end if we have else clause */
            if (node->data.if_stmt.else_stmt) {
                char jmp_instr[64];
                snprintf(jmp_instr, sizeof(jmp_instr), "    jmp %s         ; Jump to end", end_label);
                masm_append_line(ctx, jmp_instr);
                char else_label_line[64];
                snprintf(else_label_line, sizeof(else_label_line), "%s:", else_label);
                masm_append_line(ctx, else_label_line);
                
                /* Generate else statement */
                masm_append_line(ctx, "; Else statement");
                if (!masm_generate_ast_node(ctx, node->data.if_stmt.else_stmt)) {
                    printf("ERROR: Failed to generate MASM for else statement\n");
                    return false;
                }
            }
            
            char end_label_line[64];
            snprintf(end_label_line, sizeof(end_label_line), "%s:", end_label);
            masm_append_line(ctx, end_label_line);
            return true;
        }
            
        case NODE_WHILE_STMT: {
            /* Generate while statement */
            printf("DEBUG: Generating MASM while statement\n");
            
            /* Generate unique labels */
            static I64 while_label_counter = 0;
            while_label_counter++;
            char loop_label[64], end_label[64];
            snprintf(loop_label, sizeof(loop_label), "while_loop_%d", (int)while_label_counter);
            snprintf(end_label, sizeof(end_label), "while_end_%d", (int)while_label_counter);
            
            /* Generate loop start label */
            char loop_label_line[64];
            snprintf(loop_label_line, sizeof(loop_label_line), "%s:", loop_label);
            masm_append_line(ctx, loop_label_line);
            
            /* Generate condition evaluation */
            masm_append_line(ctx, "; While condition evaluation");
            if (!masm_generate_ast_node(ctx, node->data.while_stmt.condition)) {
                printf("ERROR: Failed to generate MASM for while condition\n");
                return false;
            }
            
            /* Test condition and jump to end if false */
            masm_append_line(ctx, "    test rax, rax   ; Test condition");
            char jz_instr[64];
            snprintf(jz_instr, sizeof(jz_instr), "    jz %s          ; Jump to end if false", end_label);
            masm_append_line(ctx, jz_instr);
            
            /* Generate loop body */
            masm_append_line(ctx, "; While loop body");
            if (!masm_generate_ast_node(ctx, node->data.while_stmt.body_stmt)) {
                printf("ERROR: Failed to generate MASM for while body\n");
                return false;
            }
            
            /* Jump back to loop start */
            char jmp_instr[64];
            snprintf(jmp_instr, sizeof(jmp_instr), "    jmp %s         ; Jump back to loop start", loop_label);
            masm_append_line(ctx, jmp_instr);
            
            /* Generate end label */
            char end_label_line[64];
            snprintf(end_label_line, sizeof(end_label_line), "%s:", end_label);
            masm_append_line(ctx, end_label_line);
            return true;
        }
            
        default:
            printf("WARNING: Unhandled AST node type %d in MASM generation\n", node->type);
            return true;
    }
}

Bool masm_generate_assembly_from_ast(MASMContext *ctx, ASTNode *ast, const char *filename) {
    if (!ctx || !ast || !filename) return false;
    
    printf("DEBUG: Generating MASM assembly from AST: %s\n", filename);
    
    /* Generate MASM assembly from AST */
    if (!masm_generate_header(ctx)) return false;
    
    /* Generate user_main function with all global statements */
    if (!masm_generate_user_main_function(ctx, ast)) {
        printf("ERROR: Failed to generate user_main function\n");
        return false;
    }
    
    if (!masm_generate_footer(ctx)) return false;
    
    /* Write to file */
    FILE *file = fopen(filename, "w");
    if (!file) {
        printf("ERROR: Failed to create MASM file: %s\n", filename);
        return false;
    }
    
    fwrite(ctx->output_buffer, 1, ctx->output_size, file);
    fclose(file);
    
    printf("✓ MASM assembly file generated from AST: %s (%zu bytes)\n", filename, ctx->output_size);
    
    return true;
}

/*
 * Utility Functions
 */

void masm_print_debug_info(MASMContext *ctx) {
    if (!ctx) return;
    
    printf("MASM Debug Information:\n");
    printf("  Output size: %zu bytes\n", ctx->output_size);
    printf("  Buffer capacity: %zu bytes\n", ctx->output_capacity);
    printf("  Indent level: %d\n", ctx->indent_level);
}
