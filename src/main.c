#include "holyc.h"

// Global variables
CompilerContext g_ctx = {0};

void print_usage(const char* program_name) {
    printf("HolyC Windows Port - A TempleOS HolyC compiler for Windows\n");
    printf("Usage: %s [options] <input_file>\n", program_name);
    printf("\nOptions:\n");
    printf("  -o <file>     Output file (default: input_file.c)\n");
    printf("  -h, --help    Show this help message\n");
    printf("  -v, --version Show version information\n");
    printf("  -I <dir>      Add include directory\n");
    printf("  -D <macro>    Define macro\n");
    printf("  -O <level>    Optimization level (0-3, default: 1)\n");
    printf("  -S            Output assembly instead of C\n");
    printf("  -c            Compile only, don't link\n");
    printf("\nExamples:\n");
    printf("  %s hello.hc\n", program_name);
    printf("  %s -o hello hello.hc\n", program_name);
    printf("  %s -O2 -S program.hc\n", program_name);
}

void print_version() {
    printf("SchismC v1.0.0 - A Windows Port of HolyC\n");
    printf("Based on TempleOS HolyC implementation\n");
    printf("Copyright (c) 2025\n");
}

int main(int argc, char* argv[]) {
    const char* input_file = NULL;
    const char* output_file = NULL;
    int optimization_level = 1;
    bool output_assembly = false;
    bool compile_only = false;
    
    // Parse command line arguments (simplified for Windows)
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            print_usage(argv[0]);
            return 0;
        } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0) {
            print_version();
            return 0;
        } else if (strcmp(argv[i], "-o") == 0 && i + 1 < argc) {
            output_file = argv[++i];
        } else if (argv[i][0] != '-') {
            input_file = argv[i];
        }
    }
    
    // Get input file
    if (!input_file) {
        fprintf(stderr, "Error: No input file specified\n");
        print_usage(argv[0]);
        return 1;
    }
    
    // Set default output file if not specified
    if (!output_file) {
        // Replace .hc extension with .c
        size_t len = strlen(input_file);
        char* temp = malloc(len + 3);
        strcpy(temp, input_file);
        if (len > 3 && strcmp(input_file + len - 3, ".hc") == 0) {
            strcpy(temp + len - 3, ".c");
        } else {
            strcat(temp, ".c");
        }
        output_file = temp;
    }
    
    // Open input file
    FILE* file = fopen(input_file, "r");
    if (!file) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", input_file);
        return 1;
    }
    
    // Initialize compiler context
    lex_init(&g_ctx, file, input_file);
    
    printf("Compiling %s...\n", input_file);
    
    // Reset file pointer to beginning for parsing
    fseek(file, 0, SEEK_SET);
    lex_init(&g_ctx, file, input_file);
    
    // Parse the input file
    g_ctx.ast_root = parse_program(&g_ctx);
    
    if (g_ctx.error_count > 0) {
        fprintf(stderr, "Compilation failed with %lld errors\n", g_ctx.error_count);
        if (g_ctx.warning_count > 0) {
            fprintf(stderr, "and %lld warnings\n", g_ctx.warning_count);
        }
        fclose(file);
        lex_cleanup(&g_ctx);
        parser_cleanup(g_ctx.ast_root);
        return 1;
    }
    
    if (g_ctx.warning_count > 0) {
        printf("Compilation completed with %lld warnings\n", g_ctx.warning_count);
    } else {
        printf("Compilation completed successfully\n");
    }
    
    // Generate output code
    g_ctx.output_code = generate_code(&g_ctx, g_ctx.ast_root);
    
    // Write output file
    FILE* out_file = fopen(output_file, "w");
    if (!out_file) {
        fprintf(stderr, "Error: Cannot open output file '%s'\n", output_file);
        fclose(file);
        lex_cleanup(&g_ctx);
        parser_cleanup(g_ctx.ast_root);
        free(g_ctx.output_code);
        return 1;
    }
    
    // Write header
    fprintf(out_file, "// Generated by HolyC Windows Port\n");
    fprintf(out_file, "// Source: %s\n\n", input_file);
    fprintf(out_file, "#include <stdio.h>\n");
    fprintf(out_file, "#include <stdlib.h>\n");
    fprintf(out_file, "#include <string.h>\n");
    fprintf(out_file, "#include <stdint.h>\n");
    fprintf(out_file, "#include <stdarg.h>\n");
    fprintf(out_file, "#include <stdbool.h>\n\n");
    
    // Write generated code
    if (g_ctx.output_code) {
        fprintf(out_file, "%s", g_ctx.output_code);
    }
    
    fclose(out_file);
    fclose(file);
    
    printf("Output written to %s\n", output_file);
    
    // Cleanup
    lex_cleanup(&g_ctx);
    parser_cleanup(g_ctx.ast_root);
    free(g_ctx.output_code);
    
    return 0;
}
